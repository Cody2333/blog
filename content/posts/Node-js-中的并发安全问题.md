---
title: Node.js 中的并发安全问题
tags: [
    "tech",
    "Node.js"
]
date: 2019-08-18
---

# Node.js 中的并发安全问题

## 简介

Node.js 采用非阻塞异步IO的方式来处理请求。基于 Libuv 的事件循环机制，node 得以通过单线程来处理高并发的请求。一般情况下，如果采用多线程的方式来处理并发的请求时，我们需要考虑多个线程在访问共享的数据时的线程安全问题。对应的方式一般会提供一些同步机制或锁的能力来方便开发人员解决并发问题。
那么对于单线程的 Node.js 应用，并不存在多线程的问题，是否就不需要考虑并发安全问题了呢？答案可能是否定的。

## 事件循环的并发安全

在 node 中，一个事件循环中的执行是可以保证并发安全的，不会被其他操作打断，所以如果能保证代码中的需要保证并发安全的业务都在一个事件循环中被处理，那么是不存在问题的。但是实际情况下，这并不容易做到，通常业务中的异步逻辑会在多个事件循环中被执行，从而存在并发时的数据不一致问题。
可以来看一个简单的例子。
```javascript
// 将 redis 中的 k 乘 2
const double = async () => {
  const val = await .get('k')
  await redis.set('k', val * 2)
}
const main = async () => {
  // 初始化 k, redis 是一个 redis 客户端
  await redis.set('k', 1)
  // 模拟并发的请求
  await Promise.all([double(), double()])
  const r = await redis.get('k')
  // 打印结果
  console.log(r) //2
}
main();
```
在例子中，`double` 是一个异步函数，但是 `double` 方法并不是一个原子的操作。它包含两个异步操作，会存在于两个不同的事件循环队列中。所以当并发请求这个方法的时候，最终输出的结果是 2 而不是 4。实际的执行逻辑是这样的：`get(1) -> get(1) -> set(2) -> get(2)`，而我们预期的执行应该是这样的：`get(1)->set(2)->get(2)->set(4)`。

#### 解决
为了解决异步代码的并发问题，我们只需要提供一种机制，使得 `double` 函数串行执行，也就是对这个方法加锁就行了。
[https://www.npmjs.com/package/async-lock](https://www.npmjs.com/package/async-lock)
这个库提供了锁机制的一种实现。

## 多进程模型下的并发安全

上一节讨论的是在 Node 单线程模型下的并发问题，在实际的项目部署时，由于node 是单进程的，无法充分利用多核 CPU 的性能，一般会使用 cluster 模块，进行多进程的部署。在多进程的环境下，又会带来一些并发的问题。进程之间的数据是不共享的，但是依然会有很多共享的资源，比如文件系统，数据库等。对于这些资源的并发访问和修改依然会导致问题。

继续讨论上一节中的关于 `redis` 的例子，如果仅仅是给异步函数 `double` 的执行加锁，单进程情况下它可以正常执行，但是多进程是，如果同时有两个示例执行 `double` 函数，依然会产生冲突。
所以在 cluster 模式下，需要更可靠的锁机制，保证对多个 node 实例，一次只能执行一个异步函数 `double` 。为了实现这一点，仅仅依赖单线程的 node 是不可行的，需要引入外部的状态管理。Redlock 算法提供了一种基于redis 的分布式锁的实现。关于分布式锁和redlock算法的详细介绍可以参考这个链接[https://redis.io/topics/distlock](https://redis.io/topics/distlock)

这部分内容其实讨论的更多是一般性的并发问题的解决方案而不局限在 Node 的情景下了，所以不做过多赘述了。

## 最后

本文意在提醒大家注意到 node 中的并发问题，虽然使用的是单线程的模型，但特殊情况下依然需要使用锁的机制来解决并发问题。此外，在使用 node 操作数据库等资源时，依然需要使用数据库提供的原子操作和事务的能力保证并发安全。


