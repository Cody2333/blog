<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 
			
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://Cody23333.github.io/blog/images/avatar.png" />
    
  
  
  <meta name="twitter:title" content="理解nodeJs中的stream"/>
  <meta name="twitter:description" content="简介 主要对stream这个概念做一个形象的描述和理解，同时介绍一下比较常用的API。主要参考了Node.js的官方文档。 stream的种类 Readable"/>
  
    <meta name="twitter:site" content="@your_twitter_id"/>
  
  
  
  
    <meta name="twitter:creator" content="@coooody"/>
  



		
		<meta name="author" content="coooody">
		<meta name="description" content="科科">
		<meta name="generator" content="Hugo 0.36" />
		<title>理解nodeJs中的stream &middot; Coooody&#39;s</title>
		<link rel="shortcut icon" href="https://Cody23333.github.io/blog/images/favicon.ico">
		<link rel="stylesheet" href="https://Cody23333.github.io/blog/css/style.css">
		<link rel="stylesheet" href="https://Cody23333.github.io/blog/css/highlight.css">

		
		<link rel="stylesheet" href="https://Cody23333.github.io/blog/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://Cody23333.github.io/blog/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://Cody23333.github.io/blog/posts'>Archive</a>
	<a href='https://Cody23333.github.io/blog/tags'>Tags</a>
	<a href='https://Cody23333.github.io/blog/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        理解nodeJs中的stream
                    </h1>
                    <h2 class="headline">
                    Jan 22, 2018 00:00
                    · 1423 words
                    · 3 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="https://Cody23333.github.io/blog/tags/javascript">javascript</a>
                          
                              <a href="https://Cody23333.github.io/blog/tags/nodejs">nodejs</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                  
                    <div id="toc">
                      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#stream的种类">stream的种类</a></li>
<li><a href="#stream解决的问题">stream解决的问题</a></li>
<li><a href="#缓存机制">缓存机制</a></li>
<li><a href="#writable-streams">Writable Streams</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#几个典型的可写流">几个典型的可写流：</a></li>
<li><a href="#触发的事件">触发的事件：</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#readable-streams">Readable Streams</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#几个典型的可读流">几个典型的可读流：</a></li>
<li><a href="#两种模式-flowing-and-paused">两种模式: flowing and paused</a></li>
<li><a href="#触发的事件-1">触发的事件：</a></li>
<li><a href="#readable-setencoding-encoding">readable.setEncoding(encoding)</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#http通信中的应用">HTTP通信中的应用</a></li>
</ul></li>
</ul>
</nav>
                    </div>
                  
                
                <section id="post-body">
                    

<h2 id="简介">简介</h2>

<p>主要对stream这个概念做一个形象的描述和理解，同时介绍一下比较常用的API。主要参考了Node.js的官方文档。</p>

<h2 id="stream的种类">stream的种类</h2>

<ul>
<li><a href="https://nodejs.org/api/stream.html#stream_class_stream_readable">Readable</a> - streams from which data can be read (for example <a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>).</li>
<li><a href="https://nodejs.org/api/stream.html#stream_class_stream_writable">Writable</a> - streams to which data can be written (for example <a href="https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options"><code>fs.createWriteStream()</code></a>).</li>
<li><a href="https://nodejs.org/api/stream.html#stream_class_stream_duplex">Duplex</a> - streams that are both Readable and Writable (for example <a href="https://nodejs.org/api/net.html#net_class_net_socket"><code>net.Socket</code></a>).</li>
<li><a href="https://nodejs.org/api/stream.html#stream_class_stream_transform">Transform</a> - Duplex streams that can modify or transform the data as it is written and read (for example <a href="https://nodejs.org/api/zlib.html#zlib_zlib_createdeflate_options"><code>zlib.createDeflate()</code></a>).</li>
</ul>

<h2 id="stream解决的问题">stream解决的问题</h2>

<p>设计 stream API 的一个关键目标是将数据缓冲限制到可接受的级别，从而使得不同传输速率的源可以进行数据的传输，同时不会占用过量的内存。比如，文件的读取。系统从硬盘中读取文件的速度和我们程序处理文件内容的速度是不相匹配的，而且读取的文件可能是很大的。如果不用流来读取文件，那么我们首先就需要把整个文件读取到内存中，然后程序从内存中读取文件内容来进行后续的业务处理。这会极大的消耗系统的内存，并且降低处理的效率（要先读取整个文件，再处理数据）。</p>

<p>stream这个概念是很形象的，就像是水流，可以通过管道，从一处流向另一处。比如从文件输入，最终由程序接收，进行后续的处理。而 <a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a>就是流中最关键的一个管道方法。</p>

<pre><code>// 此处代码实现了从file.txt读取数据，然后压缩数据，然后写入file.txt.gz的过程
const r = fs.createReadStream('file.txt');
const z = zlib.createGzip();
const w = fs.createWriteStream('file.txt.gz');
r.pipe(z).pipe(w);
</code></pre>

<h2 id="缓存机制">缓存机制</h2>

<p>Writeable 和 Readable stream 都将数据存储在一个自身内部的buffer中。分别<code>writable.writableBuffer</code> or <code>readable.readableBuffer</code> 可以得到buffer的数据。有一个参数<code>highWaterMark</code> 用来限制这个buffer的最大容量。从而使得流之间的数据传输可以被限制在一定的内存占用下，并且拥有较高的效率。</p>

<h2 id="writable-streams">Writable Streams</h2>

<h5 id="几个典型的可写流">几个典型的可写流：</h5>

<ul>
<li><a href="https://nodejs.org/api/http.html#http_class_http_clientrequest">HTTP requests, on the client</a></li>
<li><a href="https://nodejs.org/api/http.html#http_class_http_serverresponse">HTTP responses, on the server</a></li>
<li><a href="https://nodejs.org/api/fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="https://nodejs.org/api/zlib.html">zlib streams</a></li>
<li><a href="https://nodejs.org/api/crypto.html">crypto streams</a></li>
<li><a href="https://nodejs.org/api/net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="https://nodejs.org/api/child_process.html#child_process_subprocess_stdin">child process stdin</a></li>
<li><a href="https://nodejs.org/api/process.html#process_process_stdout"><code>process.stdout</code></a>, <a href="https://nodejs.org/api/process.html#process_process_stderr"><code>process.stderr</code></a></li>
</ul>

<pre><code>// 示例
const myStream = getWritableStreamSomehow();
myStream.write('some data');
myStream.write('some more data');
myStream.end('done writing data'); // 关闭流，不可再写入。
</code></pre>

<h5 id="触发的事件">触发的事件：</h5>

<ul>
<li>close</li>
<li><strong>drain</strong>
If a call to <a href="https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> returns <code>false</code>, the <code>'drain'</code> event will be emitted when it is appropriate to resume writing data to the stream.
不能无限制的写入，当writeable stream的内部缓存数据超过<code>highWaterMark</code> 的阈值，stream.write会返回false，这是应该停止写入，等到触发drain事件再继续写入。</li>
<li><strong>error</strong>
注意，error事件触发的时候，stream不会自动被关闭，需要手动处理关闭。</li>
<li>finish</li>
<li><strong>pipe</strong>
对应于<code>readable.pipe()</code>,有一个readable stream和该stream连通的时候触发</li>
<li>unpipe
对应于<code>readable.unpipe()</code>,有一个readable stream和该stream管道断开的时候触发</li>
</ul>

<h2 id="readable-streams">Readable Streams</h2>

<h5 id="几个典型的可读流">几个典型的可读流：</h5>

<ul>
<li><a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage">HTTP responses, on the client</a></li>
<li><a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage">HTTP requests, on the server</a></li>
<li><a href="https://nodejs.org/api/fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="https://nodejs.org/api/zlib.html">zlib streams</a></li>
<li><a href="https://nodejs.org/api/crypto.html">crypto streams</a></li>
<li><a href="https://nodejs.org/api/net.html#net_class_net_socket">TCP sockets</a></li>
<li><a href="https://nodejs.org/api/child_process.html#child_process_subprocess_stdout">child process stdout and stderr</a></li>
<li><a href="https://nodejs.org/api/process.html#process_process_stdin"><code>process.stdin</code></a></li>
</ul>

<h5 id="两种模式-flowing-and-paused">两种模式: flowing and paused</h5>

<p>readable stream 创建时都为paused模式，但是可以通过以下几个方法变为flowing：
*   Adding a <a href="https://nodejs.org/api/stream.html#stream_event_data"><code>'data'</code></a> event handler.
*   Calling the <a href="https://nodejs.org/api/stream.html#stream_readable_resume"><code>stream.resume()</code></a> method.
*   Calling the <a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options"><code>stream.pipe()</code></a> method to send the data to a <a href="https://nodejs.org/api/stream.html#stream_class_stream_writable">Writable</a>.</p>

<p>最常用的其实就是stream.pipe()了。</p>

<h5 id="触发的事件-1">触发的事件：</h5>

<ul>
<li>close</li>
<li>data</li>
<li>end</li>
<li>readable</li>
</ul>

<pre><code>// 示例
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) =&gt; {
  console.log(`Received ${chunk.length} bytes of data.`);
});
readable.on('end', () =&gt; {
  console.log('There will be no more data.');
});
</code></pre>

<h5 id="readable-setencoding-encoding">readable.setEncoding(encoding)</h5>

<p>调用readable.setEncoding(&lsquo;utf8&rsquo;)可以使得chunk的类型由buffer变为string。</p>

<pre><code>const readable = getReadableStreamSomehow();
readable.setEncoding('utf8');
readable.on('data', (chunk) =&gt; {
  assert.equal(typeof chunk, 'string');
  console.log('got %d characters of string data', chunk.length);
});
</code></pre>

<h2 id="http通信中的应用">HTTP通信中的应用</h2>

<p>看代码和注释应该就能懂了</p>

<pre><code>const http = require('http');

const server = http.createServer((req, res) =&gt; {
  // req is an http.IncomingMessage, which is a Readable Stream
  // res is an http.ServerResponse, which is a Writable Stream

  let body = '';
  // Get the data as utf8 strings.
  // If an encoding is not set, Buffer objects will be received.
  req.setEncoding('utf8');

  // Readable streams emit 'data' events once a listener is added
  req.on('data', (chunk) =&gt; {
    body += chunk;
  });

  // the end event indicates that the entire body has been received
  req.on('end', () =&gt; {
    try {
      const data = JSON.parse(body);
      // write back something interesting to the user:
      res.write(typeof data);
      res.end();
    } catch (er) {
      // uh oh! bad json!
      res.statusCode = 400;
      return res.end(`error: ${er.message}`);
    }
  });
});

server.listen(1337);

// $ curl localhost:1337 -d &quot;{}&quot;
// object
// $ curl localhost:1337 -d &quot;\&quot;foo\&quot;&quot;
// string
// $ curl localhost:1337 -d &quot;not json&quot;
// error: Unexpected token o in JSON at position 1
</code></pre>

                </section>
            </article>

            

            

            
                <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/blog/posts/%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BD%BF%E7%94%A8swagger%E7%BB%B4%E6%8A%A4node%E7%9A%84%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/">koa-swagger-decorator:基于注解根据API自动生成可视化swagger文档<aside class="dates">Feb 10 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%96%87%E7%AB%A0/">一些总结和有用的文章<aside class="dates">Feb 1 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E5%92%8C%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0------%E7%AE%80%E8%BF%B0/">对抗样本和对抗训练笔记<aside class="dates">Jan 18 2018</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E8%A7%A3%E5%86%B3%E5%8D%B8%E8%BD%BD360%E8%85%BE%E8%AE%AF%E7%AE%A1%E5%AE%B6%E7%AD%89%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E5%AF%BC%E8%87%B4windows-defender%E6%9C%8D%E5%8A%A1%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/">解决卸载360，腾讯管家等安全软件导致windows-defender服务无法启动问题<aside class="dates">Sep 18 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95babel%E7%BC%96%E8%AF%91%E7%9A%84node-js%E9%A1%B9%E7%9B%AE/">使用VSCode调试babel编译的nodeJs项目<aside class="dates">Aug 16 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8E%E3%81%AE%E5%BC%82%E4%B8%96%E7%95%8C-%E5%8A%A8%E7%94%BB%E8%84%9A%E6%9C%AC/">浏览器后の异世界-动画脚本<aside class="dates">May 21 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E7%90%86%E8%A7%A3%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9A%84kappa%E7%B3%BB%E6%95%B0/">理解统计相关性的kappa系数<aside class="dates">Apr 28 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">Git工作流的最佳实践<aside class="dates">Apr 18 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E5%9F%BA%E4%BA%8Epromise%E5%92%8Casync-await%E7%9A%84%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">基于Promise和Async-Await的异步流程控制<aside class="dates">Apr 18 2017</aside></a>
        </li>
    
        <li>
            <a href="/blog/posts/%E5%A1%AB%E5%9D%91-%E5%89%8D%E7%AB%AF%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6/">填坑-前端导出csv文件的方法<aside class="dates">Apr 18 2017</aside></a>
        </li>
    
</ul>

            

            <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.facebook.com/cody.wang.585">
        <i class="fa fa-facebook-square"></i>
    </a>
    
    <a class="symbol" href="https://www.github.com/Cody2333">
        <i class="fa fa-github-square"></i>
    </a>
    


</div>

    
    <p class="small">
    
       © Copyright 2018 <i class="fa fa-heart" aria-hidden="true"></i> coooody
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://Cody23333.github.io/blog/js/jquery-3.3.1.min.js"></script>
<script src="https://Cody23333.github.io/blog/js/main.js"></script>
<script src="https://Cody23333.github.io/blog/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
